"use strict";(self.webpackChunkcookbooknitro=self.webpackChunkcookbooknitro||[]).push([[2345],{3018:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=t(4848),s=t(8453);const a={},r="Module 8: Explaining the CodeBase of Router Nitro - Part 2",i={id:"Module8",title:"Module 8: Explaining the CodeBase of Router Nitro - Part 2",description:"Welcome to Module 8 Of Router Nitro CookBook. In this module, we'll be looking at a dApp and understanding its CodeBase. In the previous module, we understood about Step 1 which is getting the quote data. This is the Part 2 of understanding the CodeBase. Let's Begin...",source:"@site/docs/Module8.md",sourceDirName:".",slug:"/Module8",permalink:"/nitrocourse/docs/Module8",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module8.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Module 7: Explaining the CodeBase of Router Nitro - Part 1",permalink:"/nitrocourse/docs/Module7"},next:{title:"Module 9: Explaining the CodeBase of Router Nitro - Part 3",permalink:"/nitrocourse/docs/Module9"}},c={},l=[{value:"Understanding the CodeBase Part- 2",id:"understanding-the-codebase-part--2",level:3},{value:"Step2: Check and set allowance",id:"step2-check-and-set-allowance",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"module-8-explaining-the-codebase-of-router-nitro---part-2",children:(0,o.jsx)(n.code,{children:"Module 8: Explaining the CodeBase of Router Nitro - Part 2"})}),"\n",(0,o.jsxs)(n.p,{children:["Welcome to Module 8 Of Router Nitro CookBook. In this module, we'll be looking at a dApp and understanding its CodeBase. In the previous module, we understood about ",(0,o.jsx)(n.strong,{children:"Step 1"})," which is getting the quote data. This is the Part 2 of understanding the CodeBase. Let's Begin..."]}),"\n",(0,o.jsx)(n.h3,{id:"understanding-the-codebase-part--2",children:"Understanding the CodeBase Part- 2"}),"\n",(0,o.jsx)(n.p,{children:"In this module, we'll be understanding the step 2, i.e Checking and Setting an Allowance."}),"\n",(0,o.jsx)(n.h3,{id:"step2-check-and-set-allowance",children:"Step2: Check and set allowance"}),"\n",(0,o.jsx)(n.p,{children:"In Step 2 of using Router Nitro, you'll verify and configure the allowance for token transfers. This process allows Router's swap or transfer contract to safely move tokens on your behalf between blockchain networks."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'import { ethers, Contract } from \'ethers\'\n\n// ERC20 Contract ABI for "Approve" and "Allowance" functions\nconst erc20_abi = [\n    {\n        "name": "approve",\n        "inputs": [\n            {\n                "internalType": "address",\n                "name": "spender",\n                "type": "address"\n            },\n            {\n                "internalType": "uint256",\n                "name": "amount",\n                "type": "uint256"\n            }\n        ],\n        "outputs": [\n            {\n                "internalType": "bool",\n                "name": "",\n                "type": "bool"\n            }\n        ],\n        "stateMutability": "nonpayable",\n        "type": "function"\n    },\n    {\n        "name": "allowance",\n        "inputs": [\n            {\n                "internalType": "address",\n                "name": "owner",\n                "type": "address"\n            },\n            {\n                "internalType": "address",\n                "name": "spender",\n                "type": "address"\n            }\n        ],\n        "outputs": [\n            {\n                "internalType": "uint256",\n                "name": "",\n                "type": "uint256"\n            }\n        ],\n        "stateMutability": "view",\n        "type": "function"\n    }\n];\n\n// Fetch the current allowance and update if needed\nconst checkAndSetAllowance = async (wallet, tokenAddress, approvalAddress, amount) => {\n    // Transactions with the native token don\'t need approval\n    if (tokenAddress === ethers.constants.AddressZero) {\n        return\n    }\n\n    const erc20 = new Contract(tokenAddress, erc20_abi, wallet);\n    const allowance = await erc20.allowance(await wallet.getAddress(), approvalAddress);\n    if (allowance.lt(amount)) {\n        const approveTx = await erc20.approve(approvalAddress, amount, {gasPrice: await wallet.provider.getGasPrice()});\n        try {\n            await approveTx.wait();\n            console.log(`Transaction mined succesfully: ${approveTx.hash}`)\n        }\n        catch (error) {\n            console.log(`Transaction failed with error: ${error}`)\n        }\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Define ERC20 Contract ABI:"}),' We begin by defining the ABI (Application Binary Interface) for ERC20 tokens, specifically focusing on the "approve" and "allowance" functions. This ABI is essential for interacting with ERC20 token contracts.']}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["The ",(0,o.jsx)(n.code,{children:"checkAndSetAllowance"})," Function:"]})," This function checks your current allowance and, if necessary, sets a new allowance. It first checks if the token is the native token (ETH), in which case no approval is needed."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Creating an ERC20 Contract:"})," Using the provided token address and the ERC20 ABI, we create an instance of the ERC20 contract. This contract represents the token you want to set an allowance for."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Checking Current Allowance:"})," We retrieve your current allowance for the token. The allowance is the maximum amount the Voyager system (or any other address) can withdraw from your wallet."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Setting the Allowance:"})," If the current allowance is less than the desired amount, we proceed to set a new allowance. We initiate an approval transaction to the ERC20 contract, granting permission to Router's swap or transfer contract to withdraw tokens on your behalf."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Handling Transactions:"})," The code handles the approval transaction, monitors its status, and logs the transaction hash upon successful confirmation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["When the button is clicked your signer (wallet) is set up and the ",(0,o.jsx)(n.code,{children:"checkAndSetAllowance"})," function is called with the required parameters. You can find it in quote.allowanceTo in the quoteData obtained from step 1"]}),"\n",(0,o.jsx)("img",{width:"269",alt:"image",src:"https://github.com/router-resources/Voyager-2-Cookbook/assets/124175970/6ae5efe7-e589-4a61-95ad-37b8b5077c99"}),"\n",(0,o.jsxs)(n.p,{children:["Please replace ",(0,o.jsx)(n.code,{children:'"YOUR_PRIVATE_KEY"'})," and other placeholders with your actual private key and the specific token details."]}),"\n",(0,o.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"In conclusion, Module 8 of the Router Nitro CookBook provided a detailed examination of Step 2 in using Router Nitro: checking and setting an allowance for token transfers. This crucial step ensures the safe and secure movement of tokens between blockchain networks through Router's swap or transfer contract."}),"\n",(0,o.jsx)(n.p,{children:"The module delved into the codebase, offering insights into the implementation of the checkAndSetAllowance function, which automates the process of verifying and configuring allowances for token transfers. Here's a breakdown of the key components discussed:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"ERC20 Contract ABI Definition:"}),' The module began by defining the ABI (Application Binary Interface) for ERC20 tokens, specifically focusing on the "approve" and "allowance" functions. This ABI is essential for interacting with ERC20 token contracts.']}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"checkAndSetAllowance Function:"})," This function, central to Step 2, checks the current allowance and sets a new allowance if necessary. It first checks if the token is the native token (ETH), in which case no approval is needed. Then, it creates an instance of the ERC20 contract using the provided token address and ABI."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Checking and Setting Allowances:"})," The function retrieves the current allowance for the token and compares it with the desired amount. If the current allowance is less than the desired amount, a new allowance is set through an approval transaction to the ERC20 contract."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Transaction Handling:"})," The code efficiently handles the approval transaction, monitoring its status and logging the transaction hash upon successful confirmation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"By providing developers with a clear understanding of the codebase and its functionalities, Module 8 empowers them to seamlessly integrate Router Nitro into their decentralized applications, facilitating efficient and secure cross-chain token transfers. Through these insights, developers can leverage Router Nitro to enhance interoperability across diverse blockchain networks, unlocking new possibilities in the decentralized finance landscape."}),"\n",(0,o.jsx)(n.h1,{id:"share-your-learnings",children:"Share Your Learnings!"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://github.com/router-resources/Router-Nitro-CookBook/assets/124175970/23258532-0dfa-407e-b695-2ed2eb39d1bc",alt:"img"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Share your learnings on Twitter. Click ",(0,o.jsx)(n.a,{href:"https://clicktotweet.com/8BhYr",children:"here"})]})}),"\n",(0,o.jsx)(n.h1,{id:"-next-module-9-explaining-the-codebase-of-router-nitro---part-3-",children:(0,o.jsx)(n.a,{href:"/nitrocourse/docs/Module9",children:" Next: Module 9: Explaining the CodeBase of Router Nitro - Part 3 "})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var o=t(6540);const s={},a=o.createContext(s);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);