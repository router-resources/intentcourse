"use strict";(self.webpackChunkcookbooknitro=self.webpackChunkcookbooknitro||[]).push([[4138],{9129:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var s=n(4848),o=n(8453);const r={},i="Module 9: Explaining the CodeBase of Router Nitro - Part 3",a={id:"Module9",title:"Module 9: Explaining the CodeBase of Router Nitro - Part 3",description:"Welcome to Module 9 Of Router Nitro CookBook. In this module, we'll be looking at a dApp and understanding its CodeBase. In the previous module, we understood about Step 2 which is checking and setting the allowance. This is the Part 3 of understanding the CodeBase. Let's Begin...",source:"@site/docs/Module9.md",sourceDirName:".",slug:"/Module9",permalink:"/https://github.com/router-resources/nitrocourse.git/docs/Module9",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module9.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Module 8: Explaining the CodeBase of Router Nitro - Part 2",permalink:"/https://github.com/router-resources/nitrocourse.git/docs/Module8"},next:{title:"Router Nitro Course CookBook",permalink:"/https://github.com/router-resources/nitrocourse.git/docs/"}},c={},d=[{value:"Understanding the CodeBase Part- 3",id:"understanding-the-codebase-part--3",level:3},{value:"Step3: Executing the Transaction",id:"step3-executing-the-transaction",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"module-9-explaining-the-codebase-of-router-nitro---part-3",children:(0,s.jsx)(t.code,{children:"Module 9: Explaining the CodeBase of Router Nitro - Part 3"})}),"\n",(0,s.jsxs)(t.p,{children:["Welcome to Module 9 Of Router Nitro CookBook. In this module, we'll be looking at a dApp and understanding its CodeBase. In the previous module, we understood about ",(0,s.jsx)(t.strong,{children:"Step 2"})," which is checking and setting the allowance. This is the Part 3 of understanding the CodeBase. Let's Begin..."]}),"\n",(0,s.jsx)(t.h3,{id:"understanding-the-codebase-part--3",children:"Understanding the CodeBase Part- 3"}),"\n",(0,s.jsx)(t.p,{children:"In this module, we'll be understanding the step 3, i.e getTransaction."}),"\n",(0,s.jsx)(t.h3,{id:"step3-executing-the-transaction",children:"Step3: Executing the Transaction"}),"\n",(0,s.jsx)(t.p,{children:"In this step, we will explore how to execute a transaction .This process involves sending a transaction to perform the cross-chain token transfer initiated in Step 1 and configured in Step 2."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsxs)(t.strong,{children:["The ",(0,s.jsx)(t.code,{children:"getTransaction"})," Function:"]})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This function is responsible for actually executing the transaction. It takes in the following parameters"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"params"})}),": Parameters required for the transaction, which should include the source and destination token addresses, slippage tolerance, sender and receiver addresses, and the widget ID."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"quoteData"})}),": Quote data obtained from Step 1."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"When the button is clicked, It performs the following tasks using the function defined:-"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"  const provider = new ethers.providers.JsonRpcProvider(\"https://rpc.ankr.com/polygon_mumbai\", 80001);\n\n    const wallet = new ethers.Wallet(\"76313c982e5cfdc0c47e36465e5fa90e0db291667296a7bd163178b955162b13\", provider)\n\n\tconst params ={\n\t\t'fromTokenAddress': from,\n\t\t'toTokenAddress': to,\n\t\t'amount': amount,\n\t\t'fromTokenChainId': \"80001\",\n\t\t'toTokenChainId': \"43113\", // Fuji\n\n\t\t'widgetId': 0, // get your unique wdiget id by contacting us on Telegram\n\t}\n\n\tconst quoteData = await getQuote(params);\n\n\n\tconsole.log(quoteData)\n\n    const txResponse = await getTransaction({\n\t\t'fromTokenAddress': from,\n\t\t'toTokenAddress': to,\n\t\t'fromTokenChainId': \"80001\",\n\t\t'toTokenChainId': \"43113\", // Fuji\n\n\t\t'widgetId': 0, // get your unique wdiget id by contacting us on Telegram\n\t}, quoteData); // params have been defined in step 1 and quoteData has also been fetched in step 1\n\n    // sending the transaction using the data given by the pathfinder\n    const tx = await wallet.sendTransaction(txResponse.txn.execution)\n    try {\n        await tx.wait();\n        console.log(`Transaction mined successfully: ${tx.hash}`)\n    }\n    catch (error) {\n        console.log(`Transaction failed with error: ${error}`)\n    }\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Signer Setup"}),": Configures a signer using the specified JSON-RPC provider. Replace ",(0,s.jsx)(t.code,{children:'"YOUR_PRIVATE_KEY"'})," with your actual private key. You can also use the ",(0,s.jsx)(t.code,{children:"provider.getSigner()"})," method if you're implementing this for a user interface (UI)."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Retrieve Transaction Data"}),": Calls the ",(0,s.jsx)(t.code,{children:"getTransaction"})," function with the necessary parameters to fetch the transaction data from the Voyager system."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'const getTransaction = async (params, quoteData) => {\n\t\tconst endpoint = "v2/transaction"\n\t\tconst txDataUrl = `${PATH_FINDER_API_URL}/${endpoint}`\n\n\t\tconsole.log(txDataUrl)\n\n\t\ttry {\n\t\t\tconst res = await axios.post(txDataUrl, {\n\t\t\t\t...quoteData,\n\t\t\t\tfromTokenAddress: params.fromTokenAddress,\n\t\t\t\ttoTokenAddress: params.toTokenAddress,\n\t\t\t\tslippageTolerance: 0.5,\n\t\t\t\tsenderAddress: account,\n\t\t\t\treceiverAddress: account,\n\t\t\t\twidgetId: params.widgetId\n\t\t\t})\n\t\t\treturn res.data;\n\t\t} catch (e) {\n\t\t\tconsole.error(`Fetching tx data from pathfinder: ${e}`)\n\t\t}\n\t}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Send Transaction"}),": Initiates the transaction using the data obtained from the Voyager system."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transaction Handling"}),": Monitors the transaction status. If the transaction is successfully mined, it logs the transaction hash. If there is an error, it logs an error message."]}),"\n",(0,s.jsxs)(t.p,{children:["Please replace ",(0,s.jsx)(t.code,{children:'"YOUR_PRIVATE_KEY"'})," with your actual private key and ensure that you have the required parameters, including ",(0,s.jsx)(t.code,{children:"params"})," and ",(0,s.jsx)(t.code,{children:"quoteData"})," obtained from Step 1."]}),"\n",(0,s.jsx)("img",{width:"182",alt:"image",src:"https://github.com/router-resources/Voyager-2-Cookbook/assets/124175970/7ea56614-6412-43f5-aab8-5e28aa044ff8"}),"\n",(0,s.jsx)(t.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"In conclusion, Module 9 of the Router Nitro Cookbook provided an insightful exploration of Step 3 in using Router Nitro: executing the transaction for cross-chain token transfers. This final step in the process, outlined in the dApp's codebase, enables users to initiate and complete token transfers seamlessly between different blockchain networks."}),"\n",(0,s.jsx)(t.p,{children:"Here's a summary of the key points covered in this module:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:["The ",(0,s.jsx)(t.code,{children:"getTransaction"})," Function:"]})," This function is pivotal in executing the transaction. It requires parameters such as source and destination token addresses, slippage tolerance, sender and receiver addresses, and the widget ID."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transaction Setup:"})," The module guides users through setting up the necessary components for transaction execution. It includes configuring a signer using the specified JSON-RPC provider and retrieving transaction data using the ",(0,s.jsx)(t.code,{children:"getTransaction"})," function with essential parameters."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Initiating the Transaction:"})," Once the transaction data is obtained from the Voyager system, the code initiates the transaction using the provided data."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transaction Handling:"})," The code monitors the status of the transaction. Upon successful mining, it logs the transaction hash for reference. In case of errors during transaction execution, it provides error messages for debugging purposes."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Implementation Considerations:"})," Users are reminded to replace ",(0,s.jsx)(t.code,{children:'"YOUR_PRIVATE_KEY"'})," with their actual private key and ensure the availability of required parameters obtained from Step 1 of the process."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"By elucidating the intricacies of transaction execution in cross-chain token transfers, Module 9 equips developers and users with the knowledge and tools necessary to leverage Router Nitro effectively within their decentralized applications. Through these insights, users can facilitate secure, efficient, and seamless token transfers across diverse blockchain networks, thereby fostering greater interoperability and expanding the possibilities within the decentralized finance ecosystem."}),"\n",(0,s.jsx)(t.h1,{id:"share-your-learnings",children:"Share Your Learnings!"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://github.com/router-resources/Router-Nitro-CookBook/assets/124175970/23258532-0dfa-407e-b695-2ed2eb39d1bc",alt:"img"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["Share your learnings on Twitter. Click ",(0,s.jsx)(t.a,{href:"https://clicktotweet.com/zgEbl",children:"here"})]})}),"\n",(0,s.jsx)(t.h1,{id:"-next-module-10-summary--cheatsheets-",children:(0,s.jsx)(t.a,{href:"/https://github.com/router-resources/nitrocourse.git/docs/Module10",children:" Next: Module 10: Summary & Cheatsheets "})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);